# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xVfsCGmOlE7izk2VsfknoYEiaXs6GbhU
"""

# Install and update statsmodels
!pip install --upgrade statsmodels

import pandas as pd
import numpy as np
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.stattools import adfuller, kpss
try:
    from statsmodels.tsa.stattools import engle_granger
except ImportError:
    print("engle_granger not available. Using Johansen test only for cointegration.")
    engle_granger = None
from statsmodels.tsa.vector_ar.vecm import coint_johansen
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")
from google.colab import files

# Function to upload a single file and return its name
def upload_file(prompt_message):
    print(prompt_message)
    uploaded = files.upload()
    if not uploaded:
        raise FileNotFoundError("No file uploaded.")
    return list(uploaded.keys())[0]

# Upload three Excel files individually
try:
    amazon_file = upload_file("Please upload Amazon3min.xlsx")
    nvda_file = upload_file("Please upload Nvda3min.xlsx")
    meta_file = upload_file("Please upload Meta3min.xlsx")
except FileNotFoundError as e:
    print(f"Error: {e}")
    print("Ensure all three files are uploaded when prompted.")
    raise

# List uploaded files to verify
print("\nUploaded files:", [amazon_file, nvda_file, meta_file])

# Read Excel files
try:
    amazon_data = pd.read_excel(amazon_file)
    nvda_data = pd.read_excel(nvda_file)
    meta_data = pd.read_excel(meta_file)
except Exception as e:
    print(f"Error reading Excel files: {e}")
    print("Ensure files are valid Excel files with a 'Close' column.")
    raise

# Extract and preprocess closing prices
try:
    amazon_close = amazon_data['Close'].dropna().astype(float)
    nvda_close = nvda_data['Close'].dropna().astype(float)
    meta_close = meta_data['Close'].dropna().astype(float)
    if amazon_close.empty or nvda_close.empty or meta_close.empty:
        raise ValueError("One or more 'Close' columns are empty after removing NaN.")
    # Align series lengths
    min_len = min(len(amazon_close), len(nvda_close), len(meta_close))
    if min_len < len(amazon_close) or min_len < len(nvda_close) or min_len < len(meta_close):
        print(f"Warning: Series lengths differ. Truncated to {min_len} observations.")
        amazon_close = amazon_close[:min_len]
        nvda_close = nvda_close[:min_len]
        meta_close = meta_close[:min_len]
    # Log-transform to reduce scale differences
    amazon_close = np.log(amazon_close)
    nvda_close = np.log(nvda_close)
    meta_close = np.log(meta_close)
except KeyError as e:
    print(f"Error: 'Close' column not found in one of the files: {e}")
    raise
except Exception as e:
    print(f"Error preprocessing data: {e}")
    raise

# Function for unit root tests
def unit_root_tests(series, name):
    print(f"\nUnit Root Tests for {name}:")

    # ADF Test
    adf_result = adfuller(series, autolag='AIC')
    print("ADF Test:")
    print(f"Test Statistic: {adf_result[0]:.4f}")
    print(f"P-value: {adf_result[1]:.4f}")
    print("Stationary" if adf_result[1] < 0.05 else "Non-stationary")

    # KPSS Test
    kpss_result = kpss(series, regression='c')
    print("\nKPSS Test:")
    print(f"Test Statistic: {kpss_result[0]:.4f}")
    print(f"P-value: {kpss_result[1]:.4f}")
    print("Stationary" if kpss_result[1] > 0.05 else "Non-stationary")

    return adf_result[1]

# Function to plot and display correlogram
def plot_correlogram(series, name):
    plt.figure(figsize=(12, 6))

    # ACF plot
    plt.subplot(121)
    plot_acf(series, ax=plt.gca(), lags=20, title=f'ACF - {name}')

    # PACF plot
    plt.subplot(122)
    plot_pacf(series, ax=plt.gca(), lags=20, title=f'PACF - {name}')

    plt.tight_layout()
    plt.savefig(f'correlogram_{name}.png')
    plt.show()
    print(f"Correlogram saved as 'correlogram_{name}.png'")

# Function to plot cointegration graphs for pairs
def plot_cointegration_pair(series1, series2, name1, name2, eg_result=None, pair_suffix=""):
    # Standardize series for comparability
    series1_std = (series1 - series1.mean()) / series1.std()
    series2_std = (series2 - series2.mean()) / series2.std()

    # Plot standardized prices
    plt.figure(figsize=(12, 6))
    plt.plot(series1_std, label=f'{name1} (standardized)', color='blue')
    plt.plot(series2_std, label=f'{name2} (standardized)', color='orange')
    plt.title(f'Standardized Closing Prices: {name1} vs {name2}')
    plt.xlabel('Time')
    plt.ylabel('Standardized Price')
    plt.legend()
    plt.grid(True)
    plt.savefig(f'cointegration_prices_{pair_suffix}.png')
    plt.show()
    print(f"Cointegration price plot saved as 'cointegration_prices_{pair_suffix}.png'")

    # Plot Engle-Granger residual if cointegrated
    if eg_result and eg_result.pvalue < 0.05:
        residuals = eg_result.resid
        plt.figure(figsize=(12, 6))
        plt.plot(residuals, label='Engle-Granger Cointegration Residual', color='green')
        plt.axhline(0, color='black', linestyle='--')
        plt.title(f'Engle-Granger Cointegration Residual: {name1} vs {name2}')
        plt.xlabel('Time')
        plt.ylabel('Residual')
        plt.legend()
        plt.grid(True)
        plt.savefig(f'cointegration_residual_{pair_suffix}.png')
        plt.show()
        print(f"Engle-Granger residual plot saved as 'cointegration_residual_{pair_suffix}.png'")
    else:
        print(f"No Engle-Granger residual plot for {name1} vs {name2} (no cointegration or test unavailable).")

# Function to plot Johansen cointegrating relationship
def plot_johansen_cointegration(series1, series2, series3, name1, name2, name3, johansen_result=None):
    if johansen_result and johansen_result.lr1[0] > johansen_result.cvt[0, 1]:
        # Use the first eigenvector for the cointegrating relationship
        weights = johansen_result.evec[:, 0]  # First cointegrating vector
        cointegrating_series = series1 * weights[0] + series2 * weights[1] + series3 * weights[2]
        plt.figure(figsize=(12, 6))
        plt.plot(cointegrating_series, label='Johansen Cointegrating Relationship', color='purple')
        plt.axhline(cointegrating_series.mean(), color='black', linestyle='--')
        plt.title(f'Johansen Cointegrating Relationship: {name1}, {name2}, {name3}')
        plt.xlabel('Time')
        plt.ylabel('Cointegrating Series')
        plt.legend()
        plt.grid(True)
        plt.savefig('johansen_cointegration.png')
        plt.show()
        print("Johansen cointegration plot saved as 'johansen_cointegration.png'")
    else:
        print("No Johansen cointegration plot (no cointegration or test failed).")

# Perform unit root tests
amazon_pval = unit_root_tests(amazon_close, "Amazon")
nvda_pval = unit_root_tests(nvda_close, "NVDA")
meta_pval = unit_root_tests(meta_close, "Meta")

# Difference series if non-stationary
amazon_series = amazon_close.diff().dropna() if amazon_pval > 0.05 else amazon_close
nvda_series = nvda_close.diff().dropna() if nvda_pval > 0.05 else nvda_close
meta_series = meta_close.diff().dropna() if meta_pval > 0.05 else meta_close

# Plot and display correlograms
plot_correlogram(amazon_series, "Amazon")
plot_correlogram(nvda_series, "NVDA")
plot_correlogram(meta_series, "Meta")

# Fit ARMA models (ARMA(1,1)) and generate forecasts
def fit_arma_and_forecast(series, name):
    try:
        model = ARIMA(series, order=(1,0,1))
        results = model.fit()
        print(f"\nARMA(1,1) Model Results for {name}:")
        print(results.summary().tables[1])

        # Generate 10-step-ahead forecast
        forecast = results.get_forecast(steps=10)
        forecast_mean = forecast.predicted_mean
        forecast_ci = forecast.conf_int(alpha=0.05)

        print(f"\n10-Step-Ahead Forecast for {name}:")
        forecast_df = pd.DataFrame({
            'Forecast': forecast_mean,
            'Lower CI': forecast_ci.iloc[:, 0],
            'Upper CI': forecast_ci.iloc[:, 1]
        })
        print(forecast_df)

        return results
    except Exception as e:
        print(f"Error fitting ARMA model or forecasting for {name}: {e}")
        return None

amazon_arma = fit_arma_and_forecast(amazon_series, "Amazon")
nvda_arma = fit_arma_and_forecast(nvda_series, "NVDA")
meta_arma = fit_arma_and_forecast(meta_series, "Meta")

# Cointegration test for pairs
def cointegration_test_pair(series1, series2, name1, name2):
    print(f"\nCointegration Test between {name1} and {name2}:")
    eg_result = None

    # Engle-Granger test (if available)
    if engle_granger:
        try:
            eg_result = engle_granger(series1, series2)
            print("Engle-Granger Test:")
            print(f"Test Statistic: {eg_result.stat:.4f}")
            print(f"P-value: {eg_result.pvalue:.4f}")
            print("Cointegrated" if eg_result.pvalue < 0.05 else "Not Cointegrated")
        except Exception as e:
            print(f"Engle-Granger test failed: {e}")

    return eg_result

# Johansen test for all three stocks
def cointegration_test_johansen(series1, series2, series3, name1, name2, name3):
    print(f"\nJohansen Cointegration Test for {name1}, {name2}, and {name3}:")
    try:
        df = pd.DataFrame({name1: series1, name2: series2, name3: series3})
        johansen_result = coint_johansen(df, det_order=0, k_ar_diff=2)
        print("Johansen Test:")
        print(f"Trace Statistic (r=0): {johansen_result.lr1[0]:.4f}")
        print(f"Critical Value (5%, r=0): {johansen_result.cvt[0, 1]:.4f}")
        print("Cointegrated (at least one relationship)" if johansen_result.lr1[0] > johansen_result.cvt[0, 1] else "Not Cointegrated")
        return johansen_result
    except Exception as e:
        print(f"Johansen test failed (skipped): {e}")
        print("Relying on pairwise Engle-Granger tests for cointegration results.")
        return None

# Perform cointegration tests
eg_result_amzn_nvda = cointegration_test_pair(amazon_close, nvda_close, "Amazon", "NVDA")
eg_result_amzn_meta = cointegration_test_pair(amazon_close, meta_close, "Amazon", "Meta")
eg_result_nvda_meta = cointegration_test_pair(nvda_close, meta_close, "NVDA", "Meta")
johansen_result = cointegration_test_johansen(amazon_close, nvda_close, meta_close, "Amazon", "NVDA", "Meta")

# Plot cointegration for pairs
plot_cointegration_pair(amazon_close, nvda_close, "Amazon", "NVDA", eg_result_amzn_nvda, "amzn_nvda")
plot_cointegration_pair(amazon_close, meta_close, "Amazon", "Meta", eg_result_amzn_meta, "amzn_meta")
plot_cointegration_pair(nvda_close, meta_close, "NVDA", "Meta", eg_result_nvda_meta, "nvda_meta")

# Plot Johansen cointegrating relationship
plot_johansen_cointegration(amazon_close, nvda_close, meta_close, "Amazon", "NVDA", "Meta", johansen_result)

# Interpretation of Results
print("\nInterpretation of Results:")
print("1. Unit Root Tests:")
print("   - ADF Test: P-value < 0.05 suggests stationarity (rejects non-stationarity).")
print("   - KPSS Test: P-value > 0.05 suggests stationarity (fails to reject stationarity).")
print("   - Non-stationary series were differenced for ARMA modeling.")
print("2. Correlograms:")
print("   - ACF and PACF plots show the correlation structure for Amazon, NVDA, and Meta.")
print("   - Significant spikes at early lags (e.g., lag 1) justify the ARMA(1,1) model.")
print("   - Plots saved as 'correlogram_{stock}.png'.")
print("3. ARMA Models:")
print("   - ARMA(1,1) models capture short-term price dynamics for each stock.")
print("   - Significant coefficients (p < 0.05) indicate a good fit.")
print("   - Check model diagnostics in the summary for adequacy.")
print("4. Forecasts:")
print("   - 10-step-ahead forecasts (30 minutes for 3-min data) predict price movements.")
print("   - Confidence intervals show the range of uncertainty; wider intervals indicate higher uncertainty.")
print("5. Cointegration:")
print("   - Tests for stable long-run relationships between Amazon, NVDA, and Meta.")
print("   - Pairwise Engle-Granger Tests: P-value < 0.05 indicates cointegration for each pair (Amazon-NVDA, Amazon-Meta, NVDA-Meta).")
print("   - Johansen Test: Trace statistic > critical value (5%) indicates at least one cointegrating relationship among all three stocks.")
print("   - Cointegration suggests linked price movements, useful for pairs trading or portfolio management.")
print("   - No cointegration implies prices may drift apart, indicating independent trends.")
print("   - Cointegration Plots:")
print("     - Standardized Prices: Show price co-movement for each pair (saved as 'cointegration_prices_{pair}.png').")
print("     - Engle-Granger Residuals: Stationary residuals for cointegrated pairs (saved as 'cointegration_residual_{pair}.png').")
print("     - Johansen Cointegrating Relationship: Stationary series for all three stocks, if cointegrated (saved as 'johansen_cointegration.png').")
print("Note: If Johansen test fails, rely on pairwise Engle-Granger results. Ensure data is clean (no NaN, numeric). Review test statistics, p-values, plots, and forecasts carefully.")

# Install and update statsmodels
!pip install --upgrade statsmodels

import pandas as pd
import numpy as np
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.stattools import adfuller, kpss
try:
    from statsmodels.tsa.stattools import engle_granger
except ImportError:
    print("engle_granger not available. Using Johansen test only for cointegration.")
    engle_granger = None
from statsmodels.tsa.vector_ar.vecm import coint_johansen
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")
from google.colab import files

# Function to upload a single file and return its name
def upload_file(prompt_message):
    print(prompt_message)
    uploaded = files.upload()
    if not uploaded:
        raise FileNotFoundError("No file uploaded.")
    return list(uploaded.keys())[0]

# Upload three Excel files individually
try:
    amazon_file = upload_file("Please upload Amazon1min.xlsx")
    nvda_file = upload_file("Please upload Nvda1min.xlsx")
    meta_file = upload_file("Please upload Meta1min.xlsx")
except FileNotFoundError as e:
    print(f"Error: {e}")
    print("Ensure all three files are uploaded when prompted.")
    raise

# List uploaded files to verify
print("\nUploaded files:", [amazon_file, nvda_file, meta_file])

# Read Excel files
try:
    amazon_data = pd.read_excel(amazon_file)
    nvda_data = pd.read_excel(nvda_file)
    meta_data = pd.read_excel(meta_file)
except Exception as e:
    print(f"Error reading Excel files: {e}")
    print("Ensure files are valid Excel files with a 'Close' column.")
    raise

# Extract and preprocess closing prices
try:
    amazon_close = amazon_data['Close'].dropna().astype(float)
    nvda_close = nvda_data['Close'].dropna().astype(float)
    meta_close = meta_data['Close'].dropna().astype(float)
    if amazon_close.empty or nvda_close.empty or meta_close.empty:
        raise ValueError("One or more 'Close' columns are empty after removing NaN.")
    # Align series lengths
    min_len = min(len(amazon_close), len(nvda_close), len(meta_close))
    if min_len < len(amazon_close) or min_len < len(nvda_close) or min_len < len(meta_close):
        print(f"Warning: Series lengths differ. Truncated to {min_len} observations.")
        amazon_close = amazon_close[:min_len]
        nvda_close = nvda_close[:min_len]
        meta_close = meta_close[:min_len]
    # Log-transform to reduce scale differences
    amazon_close = np.log(amazon_close)
    nvda_close = np.log(nvda_close)
    meta_close = np.log(meta_close)
except KeyError as e:
    print(f"Error: 'Close' column not found in one of the files: {e}")
    raise
except Exception as e:
    print(f"Error preprocessing data: {e}")
    raise

# Function for unit root tests
def unit_root_tests(series, name):
    print(f"\nUnit Root Tests for {name}:")

    # ADF Test
    adf_result = adfuller(series, autolag='AIC')
    print("ADF Test:")
    print(f"Test Statistic: {adf_result[0]:.4f}")
    print(f"P-value: {adf_result[1]:.4f}")
    print("Stationary" if adf_result[1] < 0.05 else "Non-stationary")

    # KPSS Test
    kpss_result = kpss(series, regression='c')
    print("\nKPSS Test:")
    print(f"Test Statistic: {kpss_result[0]:.4f}")
    print(f"P-value: {kpss_result[1]:.4f}")
    print("Stationary" if kpss_result[1] > 0.05 else "Non-stationary")

    return adf_result[1]

# Function to plot and display correlogram
def plot_correlogram(series, name):
    plt.figure(figsize=(12, 6))

    # ACF plot
    plt.subplot(121)
    plot_acf(series, ax=plt.gca(), lags=20, title=f'ACF - {name}')

    # PACF plot
    plt.subplot(122)
    plot_pacf(series, ax=plt.gca(), lags=20, title=f'PACF - {name}')

    plt.tight_layout()
    plt.savefig(f'correlogram_{name}.png')
    plt.show()
    print(f"Correlogram saved as 'correlogram_{name}.png'")

# Function to plot cointegration graphs for pairs
def plot_cointegration_pair(series1, series2, name1, name2, eg_result=None, pair_suffix=""):
    # Standardize series for comparability
    series1_std = (series1 - series1.mean()) / series1.std()
    series2_std = (series2 - series2.mean()) / series2.std()

    # Plot standardized prices
    plt.figure(figsize=(12, 6))
    plt.plot(series1_std, label=f'{name1} (standardized)', color='blue')
    plt.plot(series2_std, label=f'{name2} (standardized)', color='orange')
    plt.title(f'Standardized Closing Prices: {name1} vs {name2}')
    plt.xlabel('Time')
    plt.ylabel('Standardized Price')
    plt.legend()
    plt.grid(True)
    plt.savefig(f'cointegration_prices_{pair_suffix}.png')
    plt.show()
    print(f"Cointegration price plot saved as 'cointegration_prices_{pair_suffix}.png'")

    # Plot Engle-Granger residual if cointegrated
    if eg_result and eg_result.pvalue < 0.05:
        residuals = eg_result.resid
        plt.figure(figsize=(12, 6))
        plt.plot(residuals, label='Engle-Granger Cointegration Residual', color='green')
        plt.axhline(0, color='black', linestyle='--')
        plt.title(f'Engle-Granger Cointegration Residual: {name1} vs {name2}')
        plt.xlabel('Time')
        plt.ylabel('Residual')
        plt.legend()
        plt.grid(True)
        plt.savefig(f'cointegration_residual_{pair_suffix}.png')
        plt.show()
        print(f"Engle-Granger residual plot saved as 'cointegration_residual_{pair_suffix}.png'")
    else:
        print(f"No Engle-Granger residual plot for {name1} vs {name2} (no cointegration or test unavailable).")

# Function to plot Johansen cointegrating relationship
def plot_johansen_cointegration(series1, series2, series3, name1, name2, name3, johansen_result=None):
    if johansen_result and johansen_result.lr1[0] > johansen_result.cvt[0, 1]:
        # Use the first eigenvector for the cointegrating relationship
        weights = johansen_result.evec[:, 0]  # First cointegrating vector
        cointegrating_series = series1 * weights[0] + series2 * weights[1] + series3 * weights[2]
        plt.figure(figsize=(12, 6))
        plt.plot(cointegrating_series, label='Johansen Cointegrating Relationship', color='purple')
        plt.axhline(cointegrating_series.mean(), color='black', linestyle='--')
        plt.title(f'Johansen Cointegrating Relationship: {name1}, {name2}, {name3}')
        plt.xlabel('Time')
        plt.ylabel('Cointegrating Series')
        plt.legend()
        plt.grid(True)
        plt.savefig('johansen_cointegration.png')
        plt.show()
        print("Johansen cointegration plot saved as 'johansen_cointegration.png'")
    else:
        print("No Johansen cointegration plot (no cointegration or test failed).")

# Perform unit root tests
amazon_pval = unit_root_tests(amazon_close, "Amazon")
nvda_pval = unit_root_tests(nvda_close, "NVDA")
meta_pval = unit_root_tests(meta_close, "Meta")

# Difference series if non-stationary
amazon_series = amazon_close.diff().dropna() if amazon_pval > 0.05 else amazon_close
nvda_series = nvda_close.diff().dropna() if nvda_pval > 0.05 else nvda_close
meta_series = meta_close.diff().dropna() if meta_pval > 0.05 else meta_close

# Plot and display correlograms
plot_correlogram(amazon_series, "Amazon")
plot_correlogram(nvda_series, "NVDA")
plot_correlogram(meta_series, "Meta")

# Fit ARMA models (ARMA(1,1)) and generate forecasts
def fit_arma_and_forecast(series, name):
    try:
        model = ARIMA(series, order=(1,0,1))
        results = model.fit()
        print(f"\nARMA(1,1) Model Results for {name}:")
        print(results.summary().tables[1])

        # Generate 10-step-ahead forecast
        forecast = results.get_forecast(steps=10)
        forecast_mean = forecast.predicted_mean
        forecast_ci = forecast.conf_int(alpha=0.05)

        print(f"\n10-Step-Ahead Forecast for {name}:")
        forecast_df = pd.DataFrame({
            'Forecast': forecast_mean,
            'Lower CI': forecast_ci.iloc[:, 0],
            'Upper CI': forecast_ci.iloc[:, 1]
        })
        print(forecast_df)

        return results
    except Exception as e:
        print(f"Error fitting ARMA model or forecasting for {name}: {e}")
        return None

amazon_arma = fit_arma_and_forecast(amazon_series, "Amazon")
nvda_arma = fit_arma_and_forecast(nvda_series, "NVDA")
meta_arma = fit_arma_and_forecast(meta_series, "Meta")

# Cointegration test for pairs
def cointegration_test_pair(series1, series2, name1, name2):
    print(f"\nCointegration Test between {name1} and {name2}:")
    eg_result = None

    # Engle-Granger test (if available)
    if engle_granger:
        try:
            eg_result = engle_granger(series1, series2)
            print("Engle-Granger Test:")
            print(f"Test Statistic: {eg_result.stat:.4f}")
            print(f"P-value: {eg_result.pvalue:.4f}")
            print("Cointegrated" if eg_result.pvalue < 0.05 else "Not Cointegrated")
        except Exception as e:
            print(f"Engle-Granger test failed: {e}")

    return eg_result

# Johansen test for all three stocks
def cointegration_test_johansen(series1, series2, series3, name1, name2, name3):
    print(f"\nJohansen Cointegration Test for {name1}, {name2}, and {name3}:")
    try:
        df = pd.DataFrame({name1: series1, name2: series2, name3: series3})
        johansen_result = coint_johansen(df, det_order=0, k_ar_diff=2)
        print("Johansen Test:")
        print(f"Trace Statistic (r=0): {johansen_result.lr1[0]:.4f}")
        print(f"Critical Value (5%, r=0): {johansen_result.cvt[0, 1]:.4f}")
        print("Cointegrated (at least one relationship)" if johansen_result.lr1[0] > johansen_result.cvt[0, 1] else "Not Cointegrated")
        return johansen_result
    except Exception as e:
        print(f"Johansen test failed (skipped): {e}")
        print("Relying on pairwise Engle-Granger tests for cointegration results.")
        return None

# Perform cointegration tests
eg_result_amzn_nvda = cointegration_test_pair(amazon_close, nvda_close, "Amazon", "NVDA")
eg_result_amzn_meta = cointegration_test_pair(amazon_close, meta_close, "Amazon", "Meta")
eg_result_nvda_meta = cointegration_test_pair(nvda_close, meta_close, "NVDA", "Meta")
johansen_result = cointegration_test_johansen(amazon_close, nvda_close, meta_close, "Amazon", "NVDA", "Meta")

# Plot cointegration for pairs
plot_cointegration_pair(amazon_close, nvda_close, "Amazon", "NVDA", eg_result_amzn_nvda, "amzn_nvda")
plot_cointegration_pair(amazon_close, meta_close, "Amazon", "Meta", eg_result_amzn_meta, "amzn_meta")
plot_cointegration_pair(nvda_close, meta_close, "NVDA", "Meta", eg_result_nvda_meta, "nvda_meta")

# Plot Johansen cointegrating relationship
plot_johansen_cointegration(amazon_close, nvda_close, meta_close, "Amazon", "NVDA", "Meta", johansen_result)

# Interpretation of Results
print("\nInterpretation of Results:")
print("1. Unit Root Tests:")
print("   - ADF Test: P-value < 0.05 suggests stationarity (rejects non-stationarity).")
print("   - KPSS Test: P-value > 0.05 suggests stationarity (fails to reject stationarity).")
print("   - Non-stationary series were differenced for ARMA modeling.")
print("2. Correlograms:")
print("   - ACF and PACF plots show the correlation structure for Amazon, NVDA, and Meta.")
print("   - Significant spikes at early lags (e.g., lag 1) justify the ARMA(1,1) model.")
print("   - Plots saved as 'correlogram_{stock}.png'.")
print("3. ARMA Models:")
print("   - ARMA(1,1) models capture short-term price dynamics for each stock.")
print("   - Significant coefficients (p < 0.05) indicate a good fit.")
print("   - Check model diagnostics in the summary for adequacy.")
print("4. Forecasts:")
print("   - 10-step-ahead forecasts (10 minutes for 1-min data) predict price movements.")
print("   - Confidence intervals show the range of uncertainty; wider intervals indicate higher uncertainty.")
print("5. Cointegration:")
print("   - Tests for stable long-run relationships between Amazon, NVDA, and Meta.")
print("   - Pairwise Engle-Granger Tests: P-value < 0.05 indicates cointegration for each pair (Amazon-NVDA, Amazon-Meta, NVDA-Meta).")
print("   - Johansen Test: Trace statistic > critical value (5%) indicates at least one cointegrating relationship among all three stocks.")
print("   - Cointegration suggests linked price movements, useful for pairs trading or portfolio management.")
print("   - No cointegration implies prices may drift apart, indicating independent trends.")
print("   - Cointegration Plots:")
print("     - Standardized Prices: Show price co-movement for each pair (saved as 'cointegration_prices_{pair}.png').")
print("     - Engle-Granger Residuals: Stationary residuals for cointegrated pairs (saved as 'cointegration_residual_{pair}.png').")
print("     - Johansen Cointegrating Relationship: Stationary series for all three stocks, if cointegrated (saved as 'johansen_cointegration.png').")
print("Note: If Johansen test fails, rely on pairwise Engle-Granger results. Ensure data is clean (no NaN, numeric). Review test statistics, p-values, plots, and forecasts carefully.")

from IPython.display import display, HTML
import base64
from io import BytesIO

# Function to convert plot to base64 string
def plot_to_base64(fig):
    buf = BytesIO()
    fig.savefig(buf, format='png')
    buf.seek(0)
    img_str = base64.b64encode(buf.read()).decode('utf-8')
    buf.close()
    return img_str

# Capture output as HTML
html_content = "<html><head><title>Stock Analysis Results</title></head><body>"
html_content += "<h1>Stock Analysis Results</h1>"

# Add uploaded files
html_content += "<h2>Uploaded Files</h2>"
html_content += f"<p>{[amazon_file, nvda_file, meta_file]}</p>"

# Add unit root tests
html_content += "<h2>Unit Root Tests</h2>"
for name, series in [("Amazon", amazon_close), ("NVDA", nvda_close), ("Meta", meta_close)]:
    html_content += f"<h3>{name}</h3>"
    adf_result = adfuller(series, autolag='AIC')
    kpss_result = kpss(series, regression='c')
    html_content += "<p>ADF Test:<br>"
    html_content += f"Test Statistic: {adf_result[0]:.4f}<br>"
    html_content += f"P-value: {adf_result[1]:.4f}<br>"
    html_content += f"{'Stationary' if adf_result[1] < 0.05 else 'Non-stationary'}</p>"
    html_content += "<p>KPSS Test:<br>"
    html_content += f"Test Statistic: {kpss_result[0]:.4f}<br>"
    html_content += f"P-value: {kpss_result[1]:.4f}<br>"
    html_content += f"{'Stationary' if kpss_result[1] > 0.05 else 'Non-stationary'}</p>"

# Add correlograms
html_content += "<h2>Correlograms</h2>"
for name, series in [("Amazon", amazon_series), ("NVDA", nvda_series), ("Meta", meta_series)]:
    fig = plt.figure(figsize=(12, 6))
    plt.subplot(121)
    plot_acf(series, ax=plt.gca(), lags=20, title=f'ACF - {name}')
    plt.subplot(122)
    plot_pacf(series, ax=plt.gca(), lags=20, title=f'PACF - {name}')
    plt.tight_layout()
    html_content += f"<h3>{name}</h3>"
    html_content += f'<img src="data:image/png;base64,{plot_to_base64(fig)}" alt="Correlogram {name}">'
    plt.close(fig)

# Add ARMA models and forecasts
html_content += "<h2>ARMA Models and Forecasts</h2>"
for name, series in [("Amazon", amazon_series), ("NVDA", nvda_series), ("Meta", meta_series)]:
    html_content += f"<h3>{name}</h3>"
    try:
        model = ARIMA(series, order=(1,0,1))
        results = model.fit()
        html_content += "<p>ARMA(1,1) Model Results:<br>"
        html_content += results.summary().tables[1].as_html().replace('<table>', '<table border="1">')
        forecast = results.get_forecast(steps=10)
        forecast_mean = forecast.predicted_mean
        forecast_ci = forecast.conf_int(alpha=0.05)
        forecast_df = pd.DataFrame({
            'Forecast': forecast_mean,
            'Lower CI': forecast_ci.iloc[:, 0],
            'Upper CI': forecast_ci.iloc[:, 1]
        })
        html_content += "<br>10-Step-Ahead Forecast:<br>"
        html_content += forecast_df.to_html(index=True, border=1)
        html_content += "</p>"
    except Exception as e:
        html_content += f"<p>Error fitting ARMA model for {name}: {e}</p>"

# Add cointegration tests
html_content += "<h2>Cointegration Tests</h2>"
for (series1, series2, name1, name2) in [
    (amazon_close, nvda_close, "Amazon", "NVDA"),
    (amazon_close, meta_close, "Amazon", "Meta"),
    (nvda_close, meta_close, "NVDA", "Meta")
]:
    html_content += f"<h3>{name1} vs {name2}</h3>"
    if engle_granger:
        try:
            eg_result = engle_granger(series1, series2)
            html_content += "<p>Engle-Granger Test:<br>"
            html_content += f"Test Statistic: {eg_result.stat:.4f}<br>"
            html_content += f"P-value: {eg_result.pvalue:.4f}<br>"
            html_content += f"{'Cointegrated' if eg_result.pvalue < 0.05 else 'Not Cointegrated'}</p>"
        except Exception as e:
            html_content += f"<p>Engle-Granger test failed: {e}</p>"

html_content += "<h3>Amazon, NVDA, Meta (Johansen)</h3>"
try:
    df = pd.DataFrame({"Amazon": amazon_close, "NVDA": nvda_close, "Meta": meta_close})
    johansen_result = coint_johansen(df, det_order=0, k_ar_diff=2)
    html_content += "<p>Johansen Test:<br>"
    html_content += f"Trace Statistic (r=0): {johansen_result.lr1[0]:.4f}<br>"
    html_content += f"Critical Value (5%, r=0): {johansen_result.cvt[0, 1]:.4f}<br>"
    html_content += f"{'Cointegrated (at least one relationship)' if johansen_result.lr1[0] > johansen_result.cvt[0, 1] else 'Not Cointegrated'}</p>"
except Exception as e:
    html_content += f"<p>Johansen test failed: {e}</p>"

# Add cointegration plots
html_content += "<h2>Cointegration Plots</h2>"
for (series1, series2, name1, name2, pair_suffix, eg_result) in [
    (amazon_close, nvda_close, "Amazon", "NVDA", "amzn_nvda", eg_result_amzn_nvda),
    (amazon_close, meta_close, "Amazon", "Meta", "amzn_meta", eg_result_amzn_meta),
    (nvda_close, meta_close, "NVDA", "Meta", "nvda_meta", eg_result_nvda_meta)
]:
    html_content += f"<h3>{name1} vs {name2}</h3>"
    # Standardized prices
    series1_std = (series1 - series1.mean()) / series1.std()
    series2_std = (series2 - series2.mean()) / series2.std()
    fig = plt.figure(figsize=(12, 6))
    plt.plot(series1_std, label=f'{name1} (standardized)', color='blue')
    plt.plot(series2_std, label=f'{name2} (standardized)', color='orange')
    plt.title(f'Standardized Closing Prices: {name1} vs {name2}')
    plt.xlabel('Time')
    plt.ylabel('Standardized Price')
    plt.legend()
    plt.grid(True)
    html_content += f'<img src="data:image/png;base64,{plot_to_base64(fig)}" alt="Cointegration Prices {name1} vs {name2}">'
    plt.close(fig)
    # Engle-Granger residual
    if eg_result and eg_result.pvalue < 0.05:
        fig = plt.figure(figsize=(12, 6))
        plt.plot(eg_result.resid, label='Engle-Granger Cointegration Residual', color='green')
        plt.axhline(0, color='black', linestyle='--')
        plt.title(f'Engle-Granger Cointegration Residual: {name1} vs {name2}')
        plt.xlabel('Time')
        plt.ylabel('Residual')
        plt.legend()
        plt.grid(True)
        html_content += f'<img src="data:image/png;base64,{plot_to_base64(fig)}" alt="Engle-Granger Residual {name1} vs {name2}">'
        plt.close(fig)

# Johansen cointegration plot
html_content += "<h3>Johansen Cointegrating Relationship</h3>"
if johansen_result and johansen_result.lr1[0] > johansen_result.cvt[0, 1]:
    weights = johansen_result.evec[:, 0]
    cointegrating_series = amazon_close * weights[0] + nvda_close * weights[1] + meta_close * weights[2]
    fig = plt.figure(figsize=(12, 6))
    plt.plot(cointegrating_series, label='Johansen Cointegrating Relationship', color='purple')
    plt.axhline(cointegrating_series.mean(), color='black', linestyle='--')
    plt.title('Johansen Cointegrating Relationship: Amazon, NVDA, Meta')
    plt.xlabel('Time')
    plt.ylabel('Cointegrating Series')
    plt.legend()
    plt.grid(True)
    html_content += f'<img src="data:image/png;base64,{plot_to_base64(fig)}" alt="Johansen Cointegration">'
    plt.close(fig)
else:
    html_content += "<p>No Johansen cointegration plot (no cointegration or test failed).</p>"

# Add interpretation
html_content += "<h2>Interpretation</h2>"
html_content += "<p>" + "<br>".join([
    "1. Unit Root Tests:",
    "   - ADF Test: P-value < 0.05 suggests stationarity (rejects non-stationarity).",
    "   - KPSS Test: P-value > 0.05 suggests stationarity (fails to reject stationarity).",
    "   - Non-stationary series were differenced for ARMA modeling.",
    "2. Correlograms:",
    "   - ACF and PACF plots show the correlation structure for Amazon, NVDA, and Meta.",
    "   - Significant spikes at early lags (e.g., lag 1) justify the ARMA(1,1) model.",
    "   - Plots saved as 'correlogram_{stock}.png'.",
    "3. ARMA Models:",
    "   - ARMA(1,1) models capture short-term price dynamics for each stock.",
    "   - Significant coefficients (p < 0.05) indicate a good fit.",
    "   - Check model diagnostics in the summary for adequacy.",
    "4. Forecasts:",
    "   - 10-step-ahead forecasts (10 minutes for 1-min data) predict price movements.",
    "   - Confidence intervals show the range of uncertainty; wider intervals indicate higher uncertainty.",
    "5. Cointegration:",
    "   - Tests for stable long-run relationships between Amazon, NVDA, and Meta.",
    "   - Pairwise Engle-Granger Tests: P-value < 0.05 indicates cointegration for each pair (Amazon-NVDA, Amazon-Meta, NVDA-Meta).",
    "   - Johansen Test: Trace statistic > critical value (5%) indicates at least one cointegrating relationship among all three stocks.",
    "   - Cointegration suggests linked price movements, useful for pairs trading or portfolio management.",
    "   - No cointegration implies prices may drift apart, indicating independent trends.",
    "   - Cointegration Plots:",
    "     - Standardized Prices: Show price co-movement for each pair (saved as 'cointegration_prices_{pair}.png').",
    "     - Engle-Granger Residuals: Stationary residuals for cointegrated pairs (saved as 'cointegration_residual_{pair}.png').",
    "     - Johansen Cointegrating Relationship: Stationary series for all three stocks, if cointegrated (saved as 'johansen_cointegration.png').",
    "Note: If Johansen test fails, rely on pairwise Engle-Granger results. Ensure data is clean (no NaN, numeric). Review test statistics, p-values, plots, and forecasts carefully."
]) + "</p>"

from IPython.display import display, HTML
import base64
from io import BytesIO

# Function to convert plot to base64 string
def plot_to_base64(fig):
    buf = BytesIO()
    fig.savefig(buf, format='png')
    buf.seek(0)
    img_str = base64.b64encode(buf.read()).decode('utf-8')
    buf.close()
    return img_str

# Capture output as HTML
html_content = "<html><head><title>Stock Analysis Results</title></head><body>"
html_content += "<h1>Stock Analysis Results</h1>"

# Add uploaded files
html_content += "<h2>Uploaded Files</h2>"
html_content += f"<p>{[amazon_file, nvda_file, meta_file]}</p>"

# Add unit root tests
html_content += "<h2>Unit Root Tests</h2>"
for name, series in [("Amazon", amazon_close), ("NVDA", nvda_close), ("Meta", meta_close)]:
    html_content += f"<h3>{name}</h3>"
    adf_result = adfuller(series, autolag='AIC')
    kpss_result = kpss(series, regression='c')
    html_content += "<p>ADF Test:<br>"
    html_content += f"Test Statistic: {adf_result[0]:.4f}<br>"
    html_content += f"P-value: {adf_result[1]:.4f}<br>"
    html_content += f"{'Stationary' if adf_result[1] < 0.05 else 'Non-stationary'}</p>"
    html_content += "<p>KPSS Test:<br>"
    html_content += f"Test Statistic: {kpss_result[0]:.4f}<br>"
    html_content += f"P-value: {kpss_result[1]:.4f}<br>"
    html_content += f"{'Stationary' if kpss_result[1] > 0.05 else 'Non-stationary'}</p>"

# Add correlograms
html_content += "<h2>Correlograms</h2>"
for name, series in [("Amazon", amazon_series), ("NVDA", nvda_series), ("Meta", meta_series)]:
    fig = plt.figure(figsize=(12, 6))
    plt.subplot(121)
    plot_acf(series, ax=plt.gca(), lags=20, title=f'ACF - {name}')
    plt.subplot(122)
    plot_pacf(series, ax=plt.gca(), lags=20, title=f'PACF - {name}')
    plt.tight_layout()
    html_content += f"<h3>{name}</h3>"
    html_content += f'<img src="data:image/png;base64,{plot_to_base64(fig)}" alt="Correlogram {name}">'
    plt.close(fig)

# Add ARMA models and forecasts
html_content += "<h2>ARMA Models and Forecasts</h2>"
for name, series in [("Amazon", amazon_series), ("NVDA", nvda_series), ("Meta", meta_series)]:
    html_content += f"<h3>{name}</h3>"
    try:
        model = ARIMA(series, order=(1,0,1))
        results = model.fit()
        html_content += "<p>ARMA(1,1) Model Results:<br>"
        html_content += results.summary().tables[1].as_html().replace('<table>', '<table border="1">')
        forecast = results.get_forecast(steps=10)
        forecast_mean = forecast.predicted_mean
        forecast_ci = forecast.conf_int(alpha=0.05)
        forecast_df = pd.DataFrame({
            'Forecast': forecast_mean,
            'Lower CI': forecast_ci.iloc[:, 0],
            'Upper CI': forecast_ci.iloc[:, 1]
        })
        html_content += "<br>10-Step-Ahead Forecast:<br>"
        html_content += forecast_df.to_html(index=True, border=1)
        html_content += "</p>"
    except Exception as e:
        html_content += f"<p>Error fitting ARMA model for {name}: {e}</p>"

# Add cointegration tests
html_content += "<h2>Cointegration Tests</h2>"
for (series1, series2, name1, name2) in [
    (amazon_close, nvda_close, "Amazon", "NVDA"),
    (amazon_close, meta_close, "Amazon", "Meta"),
    (nvda_close, meta_close, "NVDA", "Meta")
]:
    html_content += f"<h3>{name1} vs {name2}</h3>"
    if engle_granger:
        try:
            eg_result = engle_granger(series1, series2)
            html_content += "<p>Engle-Granger Test:<br>"
            html_content += f"Test Statistic: {eg_result.stat:.4f}<br>"
            html_content += f"P-value: {eg_result.pvalue:.4f}<br>"
            html_content += f"{'Cointegrated' if eg_result.pvalue < 0.05 else 'Not Cointegrated'}</p>"
        except Exception as e:
            html_content += f"<p>Engle-Granger test failed: {e}</p>"

html_content += "<h3>Amazon, NVDA, Meta (Johansen)</h3>"
try:
    df = pd.DataFrame({"Amazon": amazon_close, "NVDA": nvda_close, "Meta": meta_close})
    johansen_result = coint_johansen(df, det_order=0, k_ar_diff=2)
    html_content += "<p>Johansen Test:<br>"
    html_content += f"Trace Statistic (r=0): {johansen_result.lr1[0]:.4f}<br>"
    html_content += f"Critical Value (5%, r=0): {johansen_result.cvt[0, 1]:.4f}<br>"
    html_content += f"{'Cointegrated (at least one relationship)' if johansen_result.lr1[0] > johansen_result.cvt[0, 1] else 'Not Cointegrated'}</p>"
except Exception as e:
    html_content += f"<p>Johansen test failed: {e}</p>"

# Add cointegration plots
html_content += "<h2>Cointegration Plots</h2>"
for (series1, series2, name1, name2, pair_suffix, eg_result) in [
    (amazon_close, nvda_close, "Amazon", "NVDA", "amzn_nvda", eg_result_amzn_nvda),
    (amazon_close, meta_close, "Amazon", "Meta", "amzn_meta", eg_result_amzn_meta),
    (nvda_close, meta_close, "NVDA", "Meta", "nvda_meta", eg_result_nvda_meta)
]:
    html_content += f"<h3>{name1} vs {name2}</h3>"
    # Standardized prices
    series1_std = (series1 - series1.mean()) / series1.std()
    series2_std = (series2 - series2.mean()) / series2.std()
    fig = plt.figure(figsize=(12, 6))
    plt.plot(series1_std, label=f'{name1} (standardized)', color='blue')
    plt.plot(series2_std, label=f'{name2} (standardized)', color='orange')
    plt.title(f'Standardized Closing Prices: {name1} vs {name2}')
    plt.xlabel('Time')
    plt.ylabel('Standardized Price')
    plt.legend()
    plt.grid(True)
    html_content += f'<img src="data:image/png;base64,{plot_to_base64(fig)}" alt="Cointegration Prices {name1} vs {name2}">'
    plt.close(fig)
    # Engle-Granger residual
    if eg_result and eg_result.pvalue < 0.05:
        fig = plt.figure(figsize=(12, 6))
        plt.plot(eg_result.resid, label='Engle-Granger Cointegration Residual', color='green')
        plt.axhline(0, color='black', linestyle='--')
        plt.title(f'Engle-Granger Cointegration Residual: {name1} vs {name2}')
        plt.xlabel('Time')
        plt.ylabel('Residual')
        plt.legend()
        plt.grid(True)
        html_content += f'<img src="data:image/png;base64,{plot_to_base64(fig)}" alt="Engle-Granger Residual {name1} vs {name2}">'
        plt.close(fig)

# Johansen cointegration plot
html_content += "<h3>Johansen Cointegrating Relationship</h3>"
if johansen_result and johansen_result.lr1[0] > johansen_result.cvt[0, 1]:
    weights = johansen_result.evec[:, 0]
    cointegrating_series = amazon_close * weights[0] + nvda_close * weights[1] + meta_close * weights[2]
    fig = plt.figure(figsize=(12, 6))
    plt.plot(cointegrating_series, label='Johansen Cointegrating Relationship', color='purple')
    plt.axhline(cointegrating_series.mean(), color='black', linestyle='--')
    plt.title('Johansen Cointegrating Relationship: Amazon, NVDA, Meta')
    plt.xlabel('Time')
    plt.ylabel('Cointegrating Series')
    plt.legend()
    plt.grid(True)
    html_content += f'<img src="data:image/png;base64,{plot_to_base64(fig)}" alt="Johansen Cointegration">'
    plt.close(fig)
else:
    html_content += "<p>No Johansen cointegration plot (no cointegration or test failed).</p>"

# Add interpretation
html_content += "<h2>Interpretation</h2>"
html_content += "<p>" + "<br>".join([
    "1. Unit Root Tests:",
    "   - ADF Test: P-value < 0.05 suggests stationarity (rejects non-stationarity).",
    "   - KPSS Test: P-value > 0.05 suggests stationarity (fails to reject stationarity).",
    "   - Non-stationary series were differenced for ARMA modeling.",
    "2. Correlograms:",
    "   - ACF and PACF plots show the correlation structure for Amazon, NVDA, and Meta.",
    "   - Significant spikes at early lags (e.g., lag 1) justify the ARMA(1,1) model.",
    "   - Plots saved as 'correlogram_{stock}.png'.",
    "3. ARMA Models:",
    "   - ARMA(1,1) models capture short-term price dynamics for each stock.",
    "   - Significant coefficients (p < 0.05) indicate a good fit.",
    "   - Check model diagnostics in the summary for adequacy.",
    "4. Forecasts:",
    "   - 10-step-ahead forecasts (10 minutes for 1-min data) predict price movements.",
    "   - Confidence intervals show the range of uncertainty; wider intervals indicate higher uncertainty.",
    "5. Cointegration:",
    "   - Tests for stable long-run relationships between Amazon, NVDA, and Meta.",
    "   - Pairwise Engle-Granger Tests: P-value < 0.05 indicates cointegration for each pair (Amazon-NVDA, Amazon-Meta, NVDA-Meta).",
    "   - Johansen Test: Trace statistic > critical value (5%) indicates at least one cointegrating relationship among all three stocks.",
    "   - Cointegration suggests linked price movements, useful for pairs trading or portfolio management.",
    "   - No cointegration implies prices may drift apart, indicating independent trends.",
    "   - Cointegration Plots:",
    "     - Standardized Prices: Show price co-movement for each pair (saved as 'cointegration_prices_{pair}.png').",
    "     - Engle-Granger Residuals: Stationary residuals for cointegrated pairs (saved as 'cointegration_residual_{pair}.png').",
    "     - Johansen Cointegrating Relationship: Stationary series for all three stocks, if cointegrated (saved as 'johansen_cointegration.png').",
    "Note: If Johansen test fails, rely on pairwise Engle-Granger results. Ensure data is clean (no NaN, numeric). Review test statistics, p-values, plots, and forecasts carefully."
]) + "</p>"